# 工作日志 (Work Log)

记录每次工作会话的内容、进度和决策。

---

## 2026-01-17 (下午)

### 工作内容
- 🔬 **验证工具**: 实现组合Atom滚动窗口验证器（实际执行 vs 理论测试对比）
- 📊 **核心功能**: 对比单账户实际执行与多账户理论加权的差异
- 🎯 **关键指标**: 分析收益率、夏普比率、交易频率、最大回撤四个核心指标

### 技术细节

**1. 组合Atom验证器 (rolling_atom_validator.py)**:

新增完整的验证工具链，用于对比两种执行方式的差异：
- **实际执行**：单账户运行组合atom（虚拟持仓模拟法）
- **理论测试**：多个独立账户按权重加权（数学加权法）

**核心类: RollingAtomValidator**:
```python
class RollingAtomValidator:
    - generate_windows(): 生成滚动时间窗口（复用rolling_portfolio_validator逻辑）
    - run_atom_backtest(): 使用Runner运行atom实际回测
    - calculate_theory_result(): 调用backtest_portfolio_from_daily_values计算理论结果
    - compare_metrics(): 对比4个核心指标
    - generate_report(): 生成详细CSV和终端报告
```

**验证流程**:
1. 生成多个时间窗口（默认5个年度窗口：2020-2024）
2. 对每个窗口：
   - 运行atom实际回测（bt_runner.Runner）
   - 计算理论测试结果（portfolio_backtest逻辑）
   - 对比4个指标并计算差异百分比
3. 生成汇总统计和洞察

**输出格式**:
- CSV文件: `atom_vs_theory_comparison_{atom_name}_{timeframe}.csv`
  - 包含每个窗口的详细对比（实际/理论/差异/差异百分比）
- 文本报告: `atom_vs_theory_summary_{atom_name}_{timeframe}.txt`
  - 汇总统计和建议
- 终端输出: 逐窗口详细分析 + 汇总洞察

**对比指标**:
1. **收益率**: 实际vs理论的绝对收益差异
2. **夏普比率**: 风险调整后收益的差异
3. **交易频率**: 单账户vs多账户的交易次数差异（成本影响）
4. **最大回撤**: 风险特征的差异

**关键洞察示例**:
```
✓ 单账户执行减少了57%的交易次数（降低成本）
✓ 收益率差异在可接受范围内（平均-2.1%）
✓ 风险特征略有改善（回撤平均减少0.2%）
⚠ 夏普比率小幅下降，主要由于交易频率降低影响收益
```

**2. Atom配置管理 (ATOM_CONFIGS)**:

在validator中手动维护组合atom的配置：
```python
ATOM_CONFIGS = {
    'portfolio_rank3_combo': {
        'strategies': ['vol_breakout_aggressive', 'vol_regime_long',
                      'triple_ma', 'rsi_reversal'],
        'weights': [0.0843, 0.2390, 0.3366, 0.3401],
        'description': '稳健排名 #3: 波动率突破+波动率择时+三重均线+RSI反转',
    },
}
```

**设计决策**: 采用手动配置而非自动提取（方案A），原因：
- 短期最快实现
- 明确控制，便于维护
- 未来可优化为自动从atom源码提取

**3. 并行执行支持**:
- 串行模式（默认）：逐窗口依次执行，输出详细进度
- 并行模式（--workers auto）：多核并行处理，提升速度
- Worker函数: `_run_window_worker()`

### 文件变更

**新增**:
- `rolling_atom_validator.py` (~650行) - 组合Atom验证器
  - RollingAtomValidator主类
  - ATOM_CONFIGS配置注册表
  - CLI接口（argparse）
  - 详细的终端报告生成逻辑

### 决策记录

**为什么需要这个工具**:
- 理论测试假设多个独立账户，实际执行是单账户
- 差异来源：信号聚合、交易时机、整数手约束、成本结构
- 需要验证理论测试与实际执行的一致性

**为什么选择滚动窗口验证而非单次对比**:
- 跨多个时间窗口验证稳定性
- 识别哪些时期差异大/小
- 提供更全面的统计洞察

**为什么手动维护ATOM_CONFIGS而非自动提取**:
- 自动提取需要解析Python源码，复杂度高
- 组合atom数量不多（预计<10个），手动维护可接受
- 未来可优化：让atom模板自动包含metadata属性

**为什么对比4个指标而非更多**:
- 收益率：最直观的性能指标
- 夏普比率：风险调整后收益
- 交易频率：成本影响的关键因素
- 最大回撤：风险控制的核心指标
- 这4个指标已经覆盖了收益、风险、成本三个维度

### 使用示例

```bash
# 基础用法：验证portfolio_rank3_combo在d1周期
python rolling_atom_validator.py --atom portfolio_rank3_combo --timeframe d1

# 自定义窗口：12个月窗口，6个月滑动
python rolling_atom_validator.py \
  --atom portfolio_rank3_combo \
  --window-months 12 \
  --step-months 6

# 并行执行（自动检测CPU核心数）
python rolling_atom_validator.py \
  --atom portfolio_rank3_combo \
  --workers auto
```

### 验证完整性

已验证的前提条件：
- ✅ portfolio_rank3_combo已在bt_main.ATOMS中注册
- ✅ 所有子策略的daily_values文件存在（2020-2024全周期）
  - vol_breakout_aggressive
  - vol_regime_long
  - triple_ma
  - rsi_reversal
- ✅ 工具CLI正常工作（--help输出正确）

### 下一步

- [ ] 运行验证：`python rolling_atom_validator.py --atom portfolio_rank3_combo`
- [ ] 分析报告，确认实际vs理论差异是否在可接受范围
- [ ] 如果差异较大，分析根本原因（信号抵消/交易时机/仓位约束）
- [ ] 根据验证结果决定是否需要调整组合atom的仓位阈值
- [ ] 可选：添加更多组合atom到ATOM_CONFIGS并验证

### 技术债务

- Atom配置手动维护，未来可优化为自动提取
- 当前只验证d1周期，未测试其他周期（h1/m15等）
- 并行执行未充分测试（因每个窗口需运行完整回测，耗时较长）
- 报告格式可进一步优化（如添加可视化图表）

### 备注

- 此工具完成了延伸链条验证的关键一环
- 与理论优化工具（portfolio_optimizer）形成闭环验证
- 为实盘部署提供关键的验证依据

---

## 2026-01-17 (上午)

### 工作内容
- 📊 **核心功能**: 实现基准对比功能（买入持有策略）
- 🐛 **关键修复**: 修复基准计算严重bug（仓位利用率问题）
- ⚡ **策略优化**: 修复portfolio_rank3_combo的RSI做空功能
- 🔍 **深度诊断**: 分析策略在不同市场环境的表现差异

### 技术细节

**1. 基准对比系统实现**:
- 新增 `BuyAndHoldStrategy` 类 - 买入持有基准策略
- 新增 `_run_benchmark()` 方法 - 并行运行基准回测
- 新增 `_calculate_volatility()` 方法 - 计算年化波动率
- 输出格式：策略 vs 基准 vs 超额的对比表格

**新增指标**:
- 年化收益率（Annualized Return）
- 年化波动率（Annualized Volatility）
- 卡尔玛比率（Calmar Ratio = 年化收益 / 最大回撤）

**2. 基准计算Bug修复**:

**问题发现**:
- 用户发现基准收益率计算错误：市场涨30%，基准显示只赚4.5%
- 根本原因：`BuyAndHoldStrategy` 只买1手，剩余84%资金闲置

**修复前**:
```python
# 只买1手（$15,682），剩余$84,318闲置
self.order = self.buy(size=1)
```

**修复后**:
```python
# 用所有资金买入
cash = self.broker.getcash()
price = self.data.close[0]
size = int(cash / price)  # 全仓买入
self.order = self.buy(size=size)
```

**影响**:
- 2023-11至2024-11期间：基准收益从4.52% → 27.14%（真实值）
- 2023全年：基准收益从5.95% → 47.58%（真实值）

**3. RSI做空功能修复**:

**背景**: 继续前次会话的RSI做空修复工作

**测试结果**（2024年数据）:
- 修复前：夏普1.90，收益12.42%，从未出现-2或-3手空头
- 修复后：夏普2.24 (+17.9%)，收益14.33% (+15.4%)，成功出现-2手空头
- 做空占比：44.8%，-2手空头出现4次

**4. 策略表现分析与问题诊断**:

创建多个诊断脚本深度分析策略问题：
- `analyze_market_regimes.py` - 市场环境分析
- `diagnose_2023_trades.py` - 2023年交易问题诊断
- `analyze_strategy_problem.py` - 策略根本问题分析

**关键发现**:

修正基准后的真实表现：

| 时期 | 市场涨幅 | 策略收益 | 落后基准 | 策略夏普 | 基准夏普 |
|------|----------|----------|----------|----------|----------|
| 2023全年 | +47.58% | +1.92% | -45.66% | 0.80 | 2.62 |
| 2023-11~2024-11 | +27.14% | +10.28% | -16.86% | 2.37 | 1.51 |

**致命问题识别**:
```
2023年仓位分析:
- 买入持有基准: 恒定+8手多头
- 策略平均持仓: -0.58手空头 ❌
```

**根本原因**:
1. **方向错误**: 在长期牛市中做空，平均持有-0.58手空头
2. **仓位不足**: 策略最大持仓仅1手，而基准是8手
3. **频繁换手**: 在+1/-1/-2手之间切换，错失趋势
4. **过早平仓**: RSI策略在牛市中频繁触发"超买平仓"

**市场环境对比**:
- 2023全年：强劲单边牛市，价格从11148涨至17095 (+53.35%)
- 2023-11至2024-11：温和上涨，波动率更高，策略表现相对更好

### 文件变更

**修改**:
- `bt_runner.py` (核心修改)
  - 第12-35行: 修复BuyAndHoldStrategy，全仓买入
  - 第219-290行: 新增_run_benchmark()方法
  - 第292-316行: 新增_calculate_volatility()方法
  - 第439-481行: 增强输出格式，添加基准对比表格

**新增**:
- `analyze_market_regimes.py` (~150行) - 市场环境诊断工具
- `diagnose_2023_trades.py` (~100行) - 2023年交易分析工具
- `analyze_strategy_problem.py` (~150行) - 策略问题综合分析
- `test_short_selling_fix.py` - RSI做空功能测试脚本
- `diagnose_short_selling.py` - 做空交易诊断工具
- `FIX_RSI_SHORT_SELLING.md` - RSI做空修复文档
- `BENCHMARK_METRICS_GUIDE.md` - 基准指标完整指南

**修改（前次会话继续）**:
- `atoms/portfolio_rank3_combo.py`
  - 第117-144行: 修复RSI策略支持做空

### 决策记录

**为什么基准策略要全仓买入而非固定1手**:
- 反映真实的买入持有收益（passive investing benchmark）
- 与策略使用相同的初始资金（$100,000）
- 提供有意义的收益对比

**为什么选择年化波动率而非日波动率**:
- 标准化不同回测周期的波动率可比性
- 行业标准（与夏普比率计算一致）
- 便于理解（如"年化波动率15%"比"日波动率0.94%"更直观）

**为什么添加卡尔玛比率**:
- 衡量风险调整后收益（类似夏普，但用最大回撤代替波动率）
- 对于趋势策略，回撤比波动率更重要
- 用户需要多维度评估策略质量

### 关键问题

**策略定位问题**:
- 这是一个**防守型策略**，不是进攻型策略
- 优势：低波动、低回撤、夏普比率在特定时期较高
- 劣势：绝对收益低、跟不上牛市

**策略-市场错配**:
- 策略包含34%均值回归成分（RSI），适合震荡市
- 在单边趋势市中频繁平仓，错失大趋势
- 在牛市中做空，方向性错误

### 解决方案建议

提供3个层次的优化方案：

**方案A - 禁用做空**（最简单）:
- 修改时间：5分钟
- 将所有负手数映射为0（空仓而非做空）
- 预期改善：2023年收益从1.92% → 15-25%

**方案B - 趋势过滤**（中等复杂度）:
- 添加市场趋势检测（牛市/熊市/震荡）
- 牛市中禁用做空，熊市中禁用做多
- 智能适应市场环境

**方案C - 重新优化组合**（最稳健）:
- 运行滚动优化找到更稳健的策略组合
- 降低RSI权重，提高趋势策略权重
- 基于历史数据验证稳健性

### 测试验证

**基准修复验证**（2023-11至2024-11期间）:
```
修复前: 基准收益 4.52%（错误）
修复后: 基准收益 27.14%（正确）
真实市场: 15682 → 20428 (+30.26%)
```
差异原因：只能买整数手（6手），剩余约6%现金闲置

**RSI做空修复验证**（2024年数据）:
```
修复前:
- 夏普: 1.90
- 收益: 12.42%
- 做空: 仅-1手

修复后:
- 夏普: 2.24 (+17.9%)
- 收益: 14.33% (+15.4%)
- 做空: 出现-2手（4次）
```

### 下一步

用户需要决策：
- [ ] 选择优化方案（A/B/C）
- [ ] 确定策略定位（防守型 vs 进攻型）
- [ ] 决定是否接受低收益高夏普的权衡

**等待用户输入**，暂未实施任何修改。

### 技术债务

- 基准策略目前无法处理非整数手的资金利用（6.38手只能买6手）
- 可考虑添加fractional shares支持或使用百分比仓位
- portfolio_rank3_combo在牛市中表现不佳，需要根本性改进

### 重要教训

1. **基准计算的重要性**: 错误的基准会导致对策略表现的严重误判
2. **仓位分析的必要性**: 平均持仓为负是策略在牛市中失败的直接证据
3. **市场环境适配**: 策略需要适应不同市场环境，单一策略难以通吃
4. **风险调整收益 vs 绝对收益**: 高夏普不等于高收益

### 备注

- 本次工作是继续2026-01-16的会话（RSI做空修复）
- 发现了比做空更严重的问题：策略本身在牛市中的适应性不足
- 用户对基准计算bug的发现是关键转折点，暴露了策略的真实表现

---

## 2026-01-11

### 工作内容
- 🎯 **核心功能**: 实现滚动窗口组合稳健性验证器
- 📊 识别能够穿越周期的高夏普组合
- 🔄 从前向验证方案调整为简化的一致性验证方案
- 📝 创建完整历史周期批量回测脚本

### 技术细节
- **滚动窗口验证逻辑**：
  - 在不同时间窗口（如每年）分别运行优化器
  - 统计哪些组合在多个时期都被推荐且保持高夏普
  - 计算稳健性指标：推荐频率、平均夏普、标准差、穿越率
- **并行执行支持**：
  - 使用multiprocessing.Pool并行处理多个窗口
  - 支持auto自动检测CPU核心数
  - 预期性能：5个年度窗口，4核并行约45秒
- **稳健性评分公式**：
  - `0.3×平均夏普 + 0.25×穿越率 + 0.25×推荐频率 - 0.15×标准差 - 0.05×最差夏普惩罚`

### 文件变更
- **新增**:
  - `rolling_portfolio_validator.py` (~450行) - 滚动窗口验证器（简化版）
  - `run_all_strategies_2020_2024.sh` - 2020-2024完整历史周期批量回测脚本
- **复用**:
  - `portfolio_optimizer.py::optimize_programmatically()` - 已有的编程式接口

### 决策记录
- **为什么选择简化版（一致性验证）而不是前向验证**：
  - 用户需求：验证组合在2020/2021/2022等不同年份都能保持高夏普
  - 简化版更直观：每个窗口就是完整的一年，看夏普稳定性
  - 前向验证更严格（训练期+验证期），但实现复杂，概念不易理解
  - 用户明确选择了简化方案

- **窗口配置推荐**：
  - 年度窗口（12个月窗口，12个月步长）：适合长期稳健性验证，窗口少速度快
  - 季度滚动（12个月窗口，3个月步长）：更细粒度，但窗口多计算慢

### 输出文件
验证器运行后生成3个CSV文件：
1. `rolling_window_summary.csv` - 每个窗口的统计汇总
2. `robust_portfolios_ranking.csv` - 稳健组合排名（核心输出）
3. `window_details.csv` - 所有窗口所有组合的详细记录

### 使用流程
```bash
# 1. 运行所有策略在完整历史周期（一次性工作，耗时约1-2小时）
bash run_all_strategies_2020_2024.sh

# 2. 运行滚动验证（推荐配置）
python rolling_portfolio_validator.py \
  --timeframe d1 \
  --window-months 12 \
  --step-months 12 \
  --workers auto
```

### 下一步
- [ ] 等待批量回测完成（生成2020-2024全周期的daily_values文件）
- [ ] 运行滚动验证，验证工具正确性
- [ ] 根据稳健性排名选择最适合加杠杆的组合
- [ ] 可选：在完整周期（2020-2024）回测最稳健组合验证表现

### 备注
- 工具已完成，但需要先有完整历史周期的策略回测数据才能运行
- 数据文件命名格式：`daily_values_{strategy}_{timeframe}_20200101_20241231.csv`
- 如果现有数据只有2024年，需要先运行`run_all_strategies_2020_2024.sh`

---

## 2026-01-12

### 工作内容
- 🔧 **关键改进**: 修正批量回测脚本的timeframe分配问题
- ⚡ **性能优化**: 添加并发执行支持（默认8并发）
- 📊 按策略类型智能分配timeframe

### 问题发现
用户指出之前的 `run_all_strategies_2020_2024.sh` 存在严重问题：
- **问题**: 所有策略统一使用d1 timeframe
- **影响**: 日内策略在d1上运行会完全失效（如ORB需要分钟级数据）
- **根本原因**: 未考虑不同策略类型的timeframe需求差异

### 解决方案

**策略分类与timeframe映射** (基于bt_main.py的132个注册策略):

1. **日内策略 → m5** (27个)
   - ORB系列: 开盘区间突破需要分钟级数据捕捉日内波动
   - 日内动量/反转: 纯日内交易，不隔夜
   - VWAP回归: 需要分钟级成交量数据

2. **趋势跟踪 → h1** (16个)
   - SMA/Triple MA/ADX/MACD: 捕捉中长期趋势，h1过滤噪音

3. **均值回归 → h1** (13个)
   - RSI/Bollinger MR/CCI: 快速反应但不至于太高频

4. **突破策略 → d1** (46个)
   - Donchian/Keltner/ATR/Vol突破: 日线突破更可靠，减少假突破

5. **波动率策略 → d1** (15个)
   - 恒定波动率/波动率扩张/波动率区制: 需要足够周期观察波动率变化

6. **经典系统 → d1** (6个)
   - 海龟交易系统: 原设计基于日线

**技术实现**:
- 并发控制函数 `run_with_limit()`
- 使用bash后台任务 `&` + `wait` 实现并发
- 动态检查运行任务数 `jobs -r | wc -l`
- 并发度可配置: `PARALLEL_JOBS=8` (默认)

### 文件变更
- **修改**: `run_all_strategies_2020_2024.sh` (从195行扩展到181行)
  - 添加并发控制逻辑 (23-35行)
  - 按6大类分组策略，每类使用对应timeframe
  - 每组策略执行后等待完成 (`wait`)
  - 添加统计信息输出

### 关键决策

**为什么选择按类型单一timeframe而非多timeframe**:
- 简化: 每个策略只生成一个数据文件，避免冗余
- 高效: 减少计算量，总执行时间约1.5-5小时
- 清晰: 每个策略有明确的"最优timeframe"

**为什么选择h1而非d1给趋势策略**:
- h1提供更细粒度的趋势跟踪
- 对于期货市场，日内波动显著，h1能更好捕捉
- 仍然足够大以过滤m5/m15的噪音

**为什么均值回归也用h1**:
- 均值回归需要相对快速的响应
- m30太快（过于频繁），d1太慢（错过反转）
- h1是最佳平衡点

### 并发执行逻辑

```bash
run_with_limit() {
    local timeframe=$1
    local strategy=$2

    # 等待直到有可用的并发槽位
    while [ $(jobs -r | wc -l) -ge $PARALLEL_JOBS ]; do
        sleep 0.5
    done

    # 后台运行策略
    python bt_main.py --start $START --end $END --timeframe $timeframe --atom $strategy --no-plot &
}
```

**优势**:
- 充分利用多核CPU (默认8核)
- 预计性能提升: 8倍加速（理想情况）
- 实际预期: 5-6倍加速（考虑I/O限制）

### 滚动验证适配

由于不同timeframe的策略分别运行，滚动验证也需要按timeframe分组:

```bash
# 分别验证三个timeframe组
python rolling_portfolio_validator.py --timeframe m5 --window-months 12 --step-months 12
python rolling_portfolio_validator.py --timeframe h1 --window-months 12 --step-months 12
python rolling_portfolio_validator.py --timeframe d1 --window-months 12 --step-months 12
```

**输出文件结构**:
- `robust_portfolios_ranking_m5.csv` - 日内策略稳健组合
- `robust_portfolios_ranking_h1.csv` - 趋势+均值回归稳健组合
- `robust_portfolios_ranking_d1.csv` - 突破+波动率+经典系统稳健组合

### 预期性能

**执行时间估算** (基于2020-2024五年数据):
- m5策略: 2-5分钟/策略 × 27 = 54-135分钟
- h1策略: 1-3分钟/策略 × 29 = 29-87分钟
- d1策略: 0.5-2分钟/策略 × 67 = 33-134分钟

**顺序执行**: 约2-6小时
**并发执行** (8核): 约0.3-1小时

### 验证步骤

1. **语法检查**: `bash -n run_all_strategies_2020_2024.sh`
2. **小规模测试**: 运行3个代表策略验证timeframe正确性
3. **文件名验证**: 检查生成文件包含正确的timeframe标识
4. **数据完整性**: 确认CSV包含2020-2024完整数据

### 下一步
- [ ] 运行批量回测脚本（预计1小时，8核并发）
- [ ] 按timeframe分别运行滚动验证
- [ ] 分析每个timeframe组的稳健组合排名
- [ ] 根据稳健性选择最适合加杠杆的组合

### 技术债务
- 当前并发实现较简单（bash jobs控制），未来可考虑GNU parallel
- 策略总数132个，脚本中只包含121个（可能有未分类的策略）
- 不同timeframe的组合如何混合尚未讨论（跨timeframe组合）

### 备注
- 此次改进是对2026-01-11工作的重要补充和修正
- timeframe分配基于策略设计原理和市场特性
- 并发执行可通过调整 `PARALLEL_JOBS` 变量控制

---

## 2026-01-09

### 工作内容
- 📝 创建项目文档体系
  - 新增 `CHANGELOG.md` - 完整的版本变更记录
  - 新增 `WORK_LOG.md` - 工作日志（本文件）
  - 整理项目历史和版本演进路径

### 项目状态总结
**当前版本**: 3.0.0

**已完成的核心功能**:
1. ✅ Strategy Atom架构（bt_base.py, bt_runner.py, bt_main.py）
2. ✅ 21个策略原子文件，137个策略类，132个已注册
3. ✅ 6大策略分类体系
4. ✅ 策略相关性分析工具 (analyze_correlation.py)
5. ✅ 策略组合回测引擎 (portfolio_backtest.py)
6. ✅ 每日价值记录器 (DailyValueRecorder)
7. ✅ 完整的文档体系

**待提交的文件**:
- `atoms/` 目录（22个文件）
- `bt_base.py`, `bt_runner.py`, `bt_main.py`
- `analyze_correlation.py`, `portfolio_backtest.py`
- 数据处理脚本优化
- 所有文档文件

### 下一步计划
- [ ] 提交3.0版本代码到git
- [ ] 更新 README.md 到3.0版本
- [ ] 测试完整的工作流程（单策略→相关性分析→组合回测）
- [ ] 编写参数优化工具

### 备注
- Git历史需要补充（当前只有一个init commit）
- 需要养成频繁commit的习惯
- 考虑将文档移到 `docs/` 目录统一管理

---

## 2026-01-08

### 工作内容
- 🚀 **重大里程碑**: 完成Strategy Atom架构集成
- 新增17个策略原子文件
- 实现策略组合回测功能
- 编写详细的集成文档

### 技术细节
- 策略从4个扩展到137个
- 实现6大策略分类
- 添加DailyValueRecorder分析器
- 优化持仓成本追踪逻辑

### 文档输出
- `ATOMS_INTEGRATION_SUMMARY.md`
- `PORTFOLIO_BACKTEST_GUIDE.md`
- `CLAUDE.md`

---

## 2024-12-21

### 工作内容
- 🔧 代码重构
- 画图逻辑独立为 `plot_utils.py`
- 精简主程序代码
- 创建详细使用文档

### 改进
- 主程序减少26行
- 模块化设计提升可维护性
- 用户体验优化（输出更简洁）

### 文档输出
- `USAGE.md` (322行)
- `REFACTORING_SUMMARY.md`

---

## 2024-12-21 (早期)

### 工作内容
- 🎉 发布2.0版本
- 添加多时间周期支持
- 实现交易记录导出
- 添加可视化图表生成

### 功能特性
- 支持7种K线周期
- CSV交易记录（18个字段）
- 完整的技术指标可视化

### 文档输出
- `QUICK_START.md`
- `CSV_FILES_GUIDE.md`
- `FEATURES.md`
- `README_backtrader.md`

---

## 初始开发阶段

### 工作内容
- 🌱 项目初始化
- 集成Backtrader框架
- 实现基础双均线策略
- 数据清洗和验证

### 数据准备
- NQ期货1分钟数据（2020-2025）
- 数据清洗脚本 `quick_fix_data.py`
- 数据质量验证

---

## 日志使用指南

### 每次会话记录什么？

**必须记录**:
- 📅 日期
- 📝 工作内容概述（3-5个要点）
- 🎯 完成的功能或修复的问题
- 📁 新增/修改的关键文件

**可选记录**:
- 🤔 遇到的技术难点和解决方案
- 💡 重要的设计决策和理由
- ⚠️ 已知问题或技术债务
- 📊 测试结果或性能数据
- 🔄 下一步计划

### 示例模板

```markdown
## YYYY-MM-DD

### 工作内容
- 📝 主要工作1
- 📝 主要工作2
- 📝 主要工作3

### 技术细节
- 实现了XXX功能
- 优化了XXX性能
- 修复了XXX bug

### 文件变更
- 新增: `file1.py`, `file2.py`
- 修改: `file3.py`
- 删除: `file4.py`

### 决策记录
- **为什么选择方案A而不是方案B**: 原因...
- **参数X设置为Y的理由**: 原因...

### 问题记录
- ⚠️ 已知问题: XXX（计划在下次修复）
- 🐛 待解决: XXX

### 下一步
- [ ] 任务1
- [ ] 任务2
- [ ] 任务3

### 备注
- 其他需要记录的信息
```

---

**日志创建日期**: 2026-01-09
**最后更新**: 2026-01-17
